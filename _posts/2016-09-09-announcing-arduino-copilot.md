---
title: 'Announcing Arduino-Copilot'
date: 2020-01-26T01:42:00+01:00
draft: false
---

[arduino-copilot](https://hackage.haskell.org/package/arduino-copilot), released today, makes it easy to use Haskell to program an Arduino. It's a FRP style system, and uses the [Copilot](https://copilot-language.github.io/) DSL to generate embedded C code.

gotta blink before you can run
------------------------------

To make your arduino blink its LED, you only need 4 lines of Haskell:

```
import Copilot.Arduino main = arduino $ do led =: blinking delay =: constant 100 
```

Running that Haskell program generates an Arduino sketch in an `.ino` file, which can be loaded into the Arduino IDE and uploaded to the Arduino the same as any other sketch. It's also easy to use things like `Arduino-Makefile` to build and upload sketches generated by arduino-copilot.

shoulders of giants
-------------------

Copilot is quite an impressive embedding of C in Haskell. It was developed for NASA by Galois and is intended for safety-critical applications. So it's neat to be able to repurpose it into hobbyist microcontrollers. (I do hope to get more type safety added to Copilot though, currently it seems rather easy to confuse eg miles with kilometers when using it.)

I'm not the first person to use Copilot to program an Arduino. Anthony Cowley showed how to do it in [Abstractions for the Functional Roboticist](https://vimeo.com/77164337) back in 2013. But he had to write a skeleton of C code around the C generated by Copilot. Amoung other features, arduino-copilot automates generating that C skeleton. So you don't need to remember to enable GPIO pin 13 for output in the setup function; arduino-copilot sees you're using the LED and does that for you.

[frp-arduino](http://hackage.haskell.org/package/frp-arduino) was a big inspiration too, especially how easy it makes it to generate an Arduino sketch withough writing any C. The "`=:`" operator in copilot-arduino is copied from it. But ftp-arduino contains its own DSL, which seems less capable than Copilot. And when I looked at using frp-arduino for some real world sensing and control, it didn't seem to be possible to integrate it with existing Arduino libraries written in C. While I've not done that with arduino-copilot yet, I did design it so it should be reasonably easy to integrate it with any Arduino library.

a more interesting example
--------------------------

Let's do something more interesting than flashing a LED. We'll assume pin 12 of an Arduino Uno is connected to a push button. When the button is pressed, the LED should stay lit. Otherwise, flash the LED, starting out flashing it fast, but flashing slower and slower over time, and then back to fast flashing.

```
{-# LANGUAGE RebindableSyntax #-} import Copilot.Arduino.Uno main :: IO () main = arduino $ do buttonpressed <- readfrom pin12 led =: buttonpressed || blinking delay =: longer_and_longer * 2 
```

This is starting to use features of the Copilot DSL; "`buttonpressed || blinking`" combines two FRP streams together, and "`longer_and_longer * 2`" does math on a stream. What a concise and readable implementation of this Arduino's behavior!

Finishing up the demo program is the implementation of `longer_and_longer`. This part is entirely in the Copilot DSL, and actually I lifted it from some Copilot example code. It gives a reasonable flavor of what it's like to construct streams in Copilot.

```
longer_and_longer :: Stream Int16 longer_and_longer = counter true $ counter true false `mod` 64 == 0 counter :: Stream Bool -> Stream Bool -> Stream Int16 counter inc reset = cnt where cnt = if reset then 0 else if inc then z + 1 else z z = [0] ++ cnt 
```

This whole example turns into just 63 lines of C code, which compiles to a 1248 byte binary, so there's plenty of room left for larger, more complex programs.

simulating an Arduino
---------------------

One of Copilot's features is it can interpret code, without needing to run it on the target platform. So the Arduino's behavior can be simulated, without ever generating C code, right at the console!

But first, one line of code needs to be changed, to provide some button states for the simulation:

```
 buttonpressed <- readfrom' pin12 [False, False, False, True, True] 
```

Now let's see what it does:

```
# runghc demo.hs -i 5 delay: digitalWrite: (2) (13,false) (4) (13,true) (8) (13,false) (16) (13,true) (32) (13,true) 
```

Which is exactly what I described it doing! To prove that it always behaves correctly, you could use [copilot-theorem](https://hackage.haskell.org/package/copilot-theorem).

* * *

Development of arduino-copilot was sponsored by Trenton Cronholm and Jake Vosloo [on Patreon](https://patreon.com/joeyh).

  
  
from Hacker News https://ift.tt/30UNQh0