---
title: 'Syscall Call-From Verification'
date: 2019-11-28T05:34:00+01:00
draft: false
---

```
**\[[prev in list](https://marc.info/?l=openbsd-tech&m=157488269713173&w=2)\] \[[next in list](https://marc.info/?l=openbsd-tech&m=157489224118677&w=2)\] \[prev in thread\] \[[next in thread](https://marc.info/?l=openbsd-tech&m=157489224118677&w=2)\] ** ** List: [openbsd-tech](https://marc.info/?l=openbsd-tech&r=1&w=2) Subject: [syscall call-from verification](https://marc.info/?t=157488910800016&r=1&w=2) From: [Theo de Raadt ](https://marc.info/?a=144443393300001&r=1&w=2) Date: [2019-11-27 21:08:53](https://marc.info/?l=openbsd-tech&r=1&w=2&b=201911) Message-ID: [29275.1574888933 () cvs ! openbsd ! org](https://marc.info/?i=29275.1574888933%20()%20cvs%20!%20openbsd%20!%20org) \[Download RAW [message](https://marc.info/?l=openbsd-tech&m=157488907117170&q=mbox) or [body](https://marc.info/?l=openbsd-tech&m=157488907117170&q=raw)\]** The following change only permits system calls from address-ranges in the process which system calls are expected from. If you manage to upload exploit code containing a raw system call sequence and instruction, and mprotect -w+x that block, such a system call will not succeed but the process is killed. This obliges the attacker to use the libc system call stubs, which in some circumstances are difficult to find due to libc random-relinking at boot. This is done by adding 1 extra condition to the fast-path of the "syscall not on a writeable page" check. For static binaries, the valid regions are the base program's text segment and the signal trampoline page. For dynamic binaries, valid regions are ld.so's text segment, the signal trampoline, and libc.so's text segment... AND the main program's text. Unfortunately our current go build model hasn't followed solaris/macos approach yet of calling libc stubs, and uses the inappropriate "embed system calls directly" method, so for now we'll need to authorize the main program text as well. A comment in exec\_elf.c explains this. If go is adapted to call library-based system call stubs on OpenBSD as well, this problem will go away. There may be other environments creating raw system calls. I guess we'll need to find them as time goes by, and hope in time we can repair those also. The kernel performs most of these syscall-allowed registrations, but the permission for libc.so is done by ld.so once it (randomly) maps libc.so into the address space. That is the purpose of the new msyscall(2) system call. procmap has benen updated to show the syscall regions with 'e' and the stack regions with 'S'. Here is a dynamic binary: Start End rwxSep Offset Dev Inode File 0x6885cde4000 0x6885ce89000 r-x-ep 0000000000037000 04:05 51988 /usr/lib/libc.so.96.0 0x68899d05000 0x68899d06000 r-x-ep 0000000000000000 00:00 0 0x688cc8a2000 0x688cc8ae000 r-x-ep 0000000000004000 04:05 649617 /usr/libexec/ld.so 0x7f7fff7c2000 0x7f7ffffc2000 rw-S-p 0000000000000000 00:00 0 and a static binary: Start End rwxSep Offset Dev Inode File 0x1c365b518000 0x1c365b592000 r-x-ep 0000000000018000 04:00 25990 /bin/ksh 0x1c38e5174000 0x1c38e5175000 r-x-ep 0000000000000000 00:00 0 0x7f7fff7d2000 0x7f7ffffd1000 rw-S-p 0000000000000000 00:00 0 This diff has a ABI break: ld.so depends on a new kernel system call msyscall(2). Update to a -current kernel first, which contains a dummy version. After that, this may work: cd /usr/src && make includes cd \*/ld.so && make && make install build new kernel and boot it. i386 ld.so uses custom code library loading, and hasn't been tested yet. Index: sys/sys/exec.h =================================================================== RCS file: /cvs/src/sys/sys/exec.h,v retrieving revision 1.38 diff -u -p -u -r1.38 exec.h --- sys/sys/exec.h 1 Jun 2018 03:27:59 -0000 1.38 +++ sys/sys/exec.h 26 Nov 2019 23:25:47 -0000 @@ -99,6 +99,7 @@ struct exec\_vmcmd { #define VMCMD\_RELATIVE 0x0001 /\* ev\_addr is relative to base entry \*/ #define VMCMD\_BASE 0x0002 /\* marks a base entry \*/ #define VMCMD\_STACK 0x0004 /\* create with UVM\_FLAG\_STACK \*/ +#define VMCMD\_SYSCALL 0x0008 /\* create with UVM\_FLAG\_SYSCALL \*/ }; #define EXEC\_DEFAULT\_VMCMD\_SETSIZE 8 /\* # of cmds in set to start \*/ Index: sys/sys/syscall\_mi.h =================================================================== RCS file: /cvs/src/sys/sys/syscall\_mi.h,v retrieving revision 1.23 diff -u -p -u -r1.23 syscall\_mi.h --- sys/sys/syscall\_mi.h 4 Nov 2019 18:06:03 -0000 1.23 +++ sys/sys/syscall\_mi.h 25 Nov 2019 22:57:10 -0000 @@ -73,9 +73,9 @@ mi\_syscall(struct proc \*p, register\_t co uvm\_map\_inentry\_sp, p->p\_vmspace->vm\_map.sserial)) return (EPERM); - /\* PC must not be in writeable memory \*/ + /\* PC must be in un-writeable permitted text (sigtramp, libc, ld.so) \*/ if (!uvm\_map\_inentry(p, &p->p\_pcinentry, PROC\_PC(p), - "\[%s\]%d/%d pc=%lx inside %lx-%lx: writeable syscall\\n", + "\[%s\]%d/%d pc=%lx inside %lx-%lx: bogus syscall\\n", uvm\_map\_inentry\_pc, p->p\_vmspace->vm\_map.wserial)) return (EPERM); Index: sys/kern/exec\_elf.c =================================================================== RCS file: /cvs/src/sys/kern/exec\_elf.c,v retrieving revision 1.151 diff -u -p -u -r1.151 exec\_elf.c --- sys/kern/exec\_elf.c 13 May 2019 19:21:31 -0000 1.151 +++ sys/kern/exec\_elf.c 27 Nov 2019 19:59:17 -0000 @@ -456,7 +456,7 @@ elf\_load\_file(struct proc \*p, char \*path addr = ph\[i\].p\_vaddr - base\_ph->p\_vaddr; } elf\_load\_psection(&epp->ep\_vmcmds, nd.ni\_vp, - &ph\[i\], &addr, &size, &prot, flags); + &ph\[i\], &addr, &size, &prot, flags | VMCMD\_SYSCALL); /\* If entry is within this section it must be text \*/ if (eh.e\_entry >= ph\[i\].p\_vaddr && eh.e\_entry < (ph\[i\].p\_vaddr + size)) { @@ -621,6 +621,19 @@ exec\_elf\_makecmds(struct proc \*p, struct } } else addr = ELF\_NO\_ADDR; + /\* + \* static binary: main program does system calls + \* dynamic binary: regular main program won't do system + \* calls, unfortunately go binaries do... + \*/ + flags |= VMCMD\_SYSCALL; + if (interp == NULL) { + /\* + \* static binary: no ld.so, no late request for + \* syscalls inside libc,so block msyscall() + \*/ + p->p\_vmspace->vm\_map.flags |= VM\_MAP\_SYSCALL\_ONCE; + } /\* \* Calculates size of text and data segments Index: sys/kern/exec\_subr.c =================================================================== RCS file: /cvs/src/sys/kern/exec\_subr.c,v retrieving revision 1.56 diff -u -p -u -r1.56 exec\_subr.c --- sys/kern/exec\_subr.c 21 Jun 2019 09:39:48 -0000 1.56 +++ sys/kern/exec\_subr.c 26 Nov 2019 20:21:15 -0000 @@ -167,6 +167,7 @@ vmcmd\_map\_pagedvn(struct proc \*p, struct \* call this routine. \*/ struct uvm\_object \*uobj; + unsigned int syscalls = 0; int error; /\* @@ -193,11 +194,13 @@ vmcmd\_map\_pagedvn(struct proc \*p, struct /\* \* do the map \*/ + if ((cmd->ev\_flags & VMCMD\_SYSCALL) && (cmd->ev\_prot & PROT\_EXEC)) + syscalls |= UVM\_FLAG\_SYSCALL; error = uvm\_map(&p->p\_vmspace->vm\_map, &cmd->ev\_addr, cmd->ev\_len, uobj, cmd->ev\_offset, 0, UVM\_MAPFLAG(cmd->ev\_prot, PROT\_MASK, MAP\_INHERIT\_COPY, - MADV\_NORMAL, UVM\_FLAG\_COPYONW|UVM\_FLAG\_FIXED)); + MADV\_NORMAL, UVM\_FLAG\_COPYONW | UVM\_FLAG\_FIXED | syscalls)); /\* \* check for error Index: sys/kern/init\_main.c =================================================================== RCS file: /cvs/src/sys/kern/init\_main.c,v retrieving revision 1.292 diff -u -p -u -r1.292 init\_main.c --- sys/kern/init\_main.c 4 Nov 2019 17:51:22 -0000 1.292 +++ sys/kern/init\_main.c 17 Nov 2019 17:59:04 -0000 @@ -651,7 +651,8 @@ start\_init(void \*arg) if (uvm\_map(&p->p\_vmspace->vm\_map, &addr, PAGE\_SIZE, NULL, UVM\_UNKNOWN\_OFFSET, 0, UVM\_MAPFLAG(PROT\_READ | PROT\_WRITE, PROT\_MASK, MAP\_INHERIT\_COPY, - MADV\_NORMAL, UVM\_FLAG\_FIXED|UVM\_FLAG\_OVERLAY|UVM\_FLAG\_COPYONW|UVM\_FLAG\_STACK))) + MADV\_NORMAL, + UVM\_FLAG\_FIXED|UVM\_FLAG\_OVERLAY|UVM\_FLAG\_COPYONW|UVM\_FLAG\_STACK|UVM\_FLAG\_SYSCALL))) panic("init: couldn't allocate argument space"); for (pathp = &initpaths[\[0\]](https://marc.info/?l=openbsd-tech&m=157488907117170&w=2#0); (path = \*pathp) != NULL; pathp++) { Index: sys/kern/kern\_exec.c =================================================================== RCS file: /cvs/src/sys/kern/kern\_exec.c,v retrieving revision 1.209 diff -u -p -u -r1.209 kern\_exec.c --- sys/kern/kern\_exec.c 5 Nov 2019 08:18:47 -0000 1.209 +++ sys/kern/kern\_exec.c 26 Nov 2019 04:29:14 -0000 @@ -856,7 +856,7 @@ exec\_sigcode\_map(struct process \*pr, str if (uvm\_map(&pr->ps\_vmspace->vm\_map, &pr->ps\_sigcode, round\_page(sz), e->e\_sigobject, 0, 0, UVM\_MAPFLAG(PROT\_READ | PROT\_EXEC, PROT\_READ | PROT\_WRITE | PROT\_EXEC, MAP\_INHERIT\_COPY, - MADV\_RANDOM, UVM\_FLAG\_COPYONW))) { + MADV\_RANDOM, UVM\_FLAG\_COPYONW | UVM\_FLAG\_SYSCALL))) { uao\_detach(e->e\_sigobject); return (ENOMEM); } Index: sys/uvm/uvm.h =================================================================== RCS file: /cvs/src/sys/uvm/uvm.h,v retrieving revision 1.65 diff -u -p -u -r1.65 uvm.h --- sys/uvm/uvm.h 18 Jul 2019 23:47:33 -0000 1.65 +++ sys/uvm/uvm.h 17 Nov 2019 17:54:44 -0000 @@ -91,6 +91,7 @@ struct uvm { #define UVM\_ET\_STACK 0x0040 /\* this is a stack \*/ #define UVM\_ET\_WC 0x0080 /\* write combining \*/ #define UVM\_ET\_CONCEAL 0x0100 /\* omit from dumps \*/ +#define UVM\_ET\_SYSCALL 0x0200 /\* syscall text segment \*/ #define UVM\_ET\_FREEMAPPED 0x8000 /\* map entry is on free list (DEBUG) \*/ #define UVM\_ET\_ISOBJ(E) (((E)->etype & UVM\_ET\_OBJ) != 0) Index: sys/uvm/uvm\_extern.h =================================================================== RCS file: /cvs/src/sys/uvm/uvm\_extern.h,v retrieving revision 1.149 diff -u -p -u -r1.149 uvm\_extern.h --- sys/uvm/uvm\_extern.h 5 Nov 2019 08:18:47 -0000 1.149 +++ sys/uvm/uvm\_extern.h 17 Nov 2019 17:48:55 -0000 @@ -114,6 +114,7 @@ typedef int vm\_prot\_t; #define UVM\_FLAG\_STACK 0x2000000 /\* page may contain a stack \*/ #define UVM\_FLAG\_WC 0x4000000 /\* write combining \*/ #define UVM\_FLAG\_CONCEAL 0x8000000 /\* omit from dumps \*/ +#define UVM\_FLAG\_SYSCALL 0x10000000 /\* system calls allowed \*/ /\* macros to extract info \*/ #define UVM\_PROTECTION(X) ((X) & PROT\_MASK) Index: sys/uvm/uvm\_map.c =================================================================== RCS file: /cvs/src/sys/uvm/uvm\_map.c,v retrieving revision 1.252 diff -u -p -u -r1.252 uvm\_map.c --- sys/uvm/uvm\_map.c 26 Nov 2019 18:23:48 -0000 1.252 +++ sys/uvm/uvm\_map.c 26 Nov 2019 20:04:57 -0000 @@ -1080,6 +1080,10 @@ uvm\_mapanon(struct vm\_map \*map, vaddr\_t entry->advice = advice; if (prot & PROT\_WRITE) map->wserial++; + if (flags & UVM\_FLAG\_SYSCALL) { + entry->etype |= UVM\_ET\_SYSCALL; + map->wserial++; + } if (flags & UVM\_FLAG\_STACK) { entry->etype |= UVM\_ET\_STACK; if (flags & (UVM\_FLAG\_FIXED | UVM\_FLAG\_UNMAP)) @@ -1345,6 +1349,10 @@ uvm\_map(struct vm\_map \*map, vaddr\_t \*add entry->advice = advice; if (prot & PROT\_WRITE) map->wserial++; + if (flags & UVM\_FLAG\_SYSCALL) { + entry->etype |= UVM\_ET\_SYSCALL; + map->wserial++; + } if (flags & UVM\_FLAG\_STACK) { entry->etype |= UVM\_ET\_STACK; if (flags & UVM\_FLAG\_UNMAP) @@ -1808,12 +1816,15 @@ uvm\_map\_inentry\_sp(vm\_map\_entry\_t entry) /\* \* If a syscall comes from a writeable entry, W^X is violated. \* (Would be nice if we can spot aliasing, which is also kind of bad) + \* Ensure system call comes from libc or ld.so's text segment. \*/ int uvm\_map\_inentry\_pc(vm\_map\_entry\_t entry) { if (entry->protection & PROT\_WRITE) return (0); /\* not permitted \*/ + if ((entry->etype & UVM\_ET\_SYSCALL) == 0) + return (0); /\* not permitted \*/ return (1); } @@ -3089,12 +3100,14 @@ uvm\_map\_printit(struct vm\_map \*map, bool entry, entry->start, entry->end, entry->object.uvm\_obj, (long long)entry->offset, entry->aref.ar\_amap, entry->aref.ar\_pageoff); - (\*pr)("\\tsubmap=%c, cow=%c, nc=%c, stack=%c, prot(max)=%d/%d, inh=%d, " + (\*pr)("\\tsubmap=%c, cow=%c, nc=%c, stack=%c, " + "syscall=%c, prot(max)=%d/%d, inh=%d, " "wc=%d, adv=%d\\n", (entry->etype & UVM\_ET\_SUBMAP) ? 'T' : 'F', (entry->etype & UVM\_ET\_COPYONWRITE) ? 'T' : 'F', (entry->etype & UVM\_ET\_NEEDSCOPY) ? 'T' : 'F', (entry->etype & UVM\_ET\_STACK) ? 'T' : 'F', + (entry->etype & UVM\_ET\_SYSCALL) ? 'T' : 'F', entry->protection, entry->max\_protection, entry->inheritance, entry->wired\_count, entry->advice); @@ -3511,7 +3524,7 @@ uvmspace\_exec(struct proc \*p, vaddr\_t st \* when a process execs another program image. \*/ vm\_map\_lock(map); - vm\_map\_modflags(map, 0, VM\_MAP\_WIREFUTURE); + vm\_map\_modflags(map, 0, VM\_MAP\_WIREFUTURE|VM\_MAP\_SYSCALL\_ONCE); /\* \* now unmap the old program @@ -4284,6 +4297,45 @@ uvm\_map\_inherit(struct vm\_map \*map, vadd entry = RBT\_NEXT(uvm\_map\_addr, entry); } + vm\_map\_unlock(map); + return (0); +} + +/\* + \* uvm\_map\_syscall: permit system calls for range of addrs in map. + \* + \* => map must be unlocked + \*/ +int +uvm\_map\_syscall(struct vm\_map \*map, vaddr\_t start, vaddr\_t end) +{ + struct vm\_map\_entry \*entry; + + if (start > end) + return EINVAL; + start = MAX(start, map->min\_offset); + end = MIN(end, map->max\_offset); + if (start >= end) + return 0; + if (map->flags & VM\_MAP\_SYSCALL\_ONCE) /\* only allowed once \*/ + return (EPERM); + + vm\_map\_lock(map); + + entry = uvm\_map\_entrybyaddr(&map->addr, start); + if (entry->end > start) + UVM\_MAP\_CLIP\_START(map, entry, start); + else + entry = RBT\_NEXT(uvm\_map\_addr, entry); + + while (entry != NULL && entry->start < end) { + UVM\_MAP\_CLIP\_END(map, entry, end); + entry->etype |= UVM\_ET\_SYSCALL; + entry = RBT\_NEXT(uvm\_map\_addr, entry); + } + + map->wserial++; + map->flags |= VM\_MAP\_SYSCALL\_ONCE; vm\_map\_unlock(map); return (0); } Index: sys/uvm/uvm\_map.h =================================================================== RCS file: /cvs/src/sys/uvm/uvm\_map.h,v retrieving revision 1.64 diff -u -p -u -r1.64 uvm\_map.h --- sys/uvm/uvm\_map.h 2 Nov 2019 09:36:08 -0000 1.64 +++ sys/uvm/uvm\_map.h 26 Nov 2019 18:34:04 -0000 @@ -350,6 +350,7 @@ struct vm\_map { #define VM\_MAP\_WANTLOCK 0x10 /\* rw: want to write-lock \*/ #define VM\_MAP\_GUARDPAGES 0x20 /\* rw: add guard pgs to map \*/ #define VM\_MAP\_ISVMSPACE 0x40 /\* ro: map is a vmspace \*/ +#define VM\_MAP\_SYSCALL\_ONCE 0x80 /\* rw: libc syscall registered \*/ /\* XXX: number of kernel maps and entries to statically allocate \*/ @@ -395,6 +396,7 @@ int uvm\_map\_extract(struct vm\_map\*, vad int); vaddr\_t uvm\_map\_pie(vaddr\_t); vaddr\_t uvm\_map\_hint(struct vmspace \*, vm\_prot\_t, vaddr\_t, vaddr\_t); +int uvm\_map\_syscall(vm\_map\_t, vaddr\_t, vaddr\_t); int uvm\_map\_inherit(vm\_map\_t, vaddr\_t, vaddr\_t, vm\_inherit\_t); int uvm\_map\_advice(vm\_map\_t, vaddr\_t, vaddr\_t, int); void uvm\_map\_init(void); Index: sys/uvm/uvm\_mmap.c =================================================================== RCS file: /cvs/src/sys/uvm/uvm\_mmap.c,v retrieving revision 1.158 diff -u -p -u -r1.158 uvm\_mmap.c --- sys/uvm/uvm\_mmap.c 27 Nov 2019 01:04:13 -0000 1.158 +++ sys/uvm/uvm\_mmap.c 27 Nov 2019 01:26:27 -0000 @@ -606,7 +606,7 @@ sys\_msyscall(struct proc \*p, void \*v, re if (addr > SIZE\_MAX - size) return (EINVAL); /\* disallow wrap-around. \*/ - return (0); + return (uvm\_map\_syscall(&p->p\_vmspace->vm\_map, addr, addr+size)); } /\* Index: libexec/ld.so/Makefile =================================================================== RCS file: /cvs/src/libexec/ld.so/Makefile,v retrieving revision 1.77 diff -u -p -u -r1.77 Makefile --- libexec/ld.so/Makefile 20 Oct 2019 03:44:49 -0000 1.77 +++ libexec/ld.so/Makefile 26 Nov 2019 16:10:46 -0000 @@ -28,7 +28,7 @@ SRCS+= dl\_uname.c dl\_dirname.c strlcat.c SRCS+= malloc.c reallocarray.c tib.c ffs.c syscall=\_\_syscall close exit fstat getdents getentropy getthrid issetugid \\ - mprotect munmap open pledge read \_\_realpath sendsyslog \\ + mprotect munmap msyscall open pledge read \_\_realpath sendsyslog \\ \_\_set\_tcb sysctl thrkill utrace write GEN\_PREFIX=\\t.file "${@:R}.c"\\n\\#include "SYS.h" Index: libexec/ld.so/library.c =================================================================== RCS file: /cvs/src/libexec/ld.so/library.c,v retrieving revision 1.83 diff -u -p -u -r1.83 library.c --- libexec/ld.so/library.c 4 Oct 2019 17:42:16 -0000 1.83 +++ libexec/ld.so/library.c 26 Nov 2019 23:25:31 -0000 @@ -102,7 +102,8 @@ \_dl\_tryload\_shlib(const char \*libname, i Elf\_Addr libaddr, loff, align = \_dl\_pagesz - 1; Elf\_Addr relro\_addr = 0, relro\_size = 0; elf\_object\_t \*object; - char hbuf\[4096\]; + char hbuf\[4096\], \*exec\_start = 0; + size\_t exec\_size = 0; Elf\_Dyn \*dynp = NULL; Elf\_Ehdr \*ehdr; Elf\_Phdr \*phdp; @@ -253,6 +254,11 @@ \_dl\_tryload\_shlib(const char \*libname, i \_dl\_load\_list\_free(load\_list); return(0); } + if ((flags & PROT\_EXEC) && exec\_start == 0) { + exec\_start = start; + exec\_size = ROUND\_PG(size); + } + if (phdp->p\_flags & PF\_W) { /\* Zero out everything past the EOF \*/ if ((size & align) != 0) @@ -301,6 +307,8 @@ \_dl\_tryload\_shlib(const char \*libname, i (Elf\_Phdr \*)((char \*)libaddr + ehdr->e\_phoff), ehdr->e\_phnum,type, libaddr, loff); if (object) { + char \*soname = (char \*)object->Dyn.info\[DT\_SONAME\]; + object->load\_size = maxva - minva; /\*XXX\*/ object->load\_list = load\_list; /\* set inode, dev from stat info \*/ @@ -312,6 +320,13 @@ \_dl\_tryload\_shlib(const char \*libname, i \_dl\_set\_sod(object->load\_name, &object->sod); if (ptls != NULL && ptls->p\_memsz) \_dl\_set\_tls(object, ptls, libaddr, libname); + + /\* Request permission for system calls in libc.so's text segment \*/ + if (soname != NULL && + \_dl\_strncmp(soname, "libc.so.", 8) == 0) { + if (\_dl\_msyscall(exec\_start, exec\_size) == -1) + \_dl\_printf("msyscall %lx %lx error\\n"); + } } else { \_dl\_munmap((void \*)libaddr, maxva - minva); \_dl\_load\_list\_free(load\_list); Index: libexec/ld.so/library\_mquery.c =================================================================== RCS file: /cvs/src/libexec/ld.so/library\_mquery.c,v retrieving revision 1.60 diff -u -p -u -r1.60 library\_mquery.c --- libexec/ld.so/library\_mquery.c 4 Oct 2019 17:42:16 -0000 1.60 +++ libexec/ld.so/library\_mquery.c 26 Nov 2019 23:43:16 -0000 @@ -112,7 +112,8 @@ \_dl\_tryload\_shlib(const char \*libname, i Elf\_Phdr \*ptls = NULL; Elf\_Addr relro\_addr = 0, relro\_size = 0; struct stat sb; - char hbuf\[4096\]; + char hbuf\[4096\], \*exec\_start = 0; + size\_t exec\_size = 0; #define ROUND\_PG(x) (((x) + align) & ~(align)) #define TRUNC\_PG(x) ((x) & ~(align)) @@ -288,6 +289,11 @@ retry: load\_end = (Elf\_Addr)ld->start + ROUND\_PG(ld->size); } + if ((flags & PROT\_EXEC) && exec\_start == 0) { + exec\_start = ld->start; + exec\_size = ROUND\_PG(ld->size); + } + phdp = (Elf\_Phdr \*)(hbuf + ehdr->e\_phoff); for (i = 0; i < ehdr->e\_phnum; i++, phdp++) { if (phdp->p\_type == PT\_OPENBSD\_RANDOMIZE) @@ -318,6 +324,13 @@ retry: if (ptls != NULL && ptls->p\_memsz) \_dl\_set\_tls(object, ptls, (Elf\_Addr)lowld->start, libname); + + /\* Request permission for system calls in libc.so's text segment \*/ + if (soname != NULL && + \_dl\_strncmp(soname, "libc.so.", 8) == 0) { + if (\_dl\_msyscall(exec\_start, exec\_size) == -1) + \_dl\_printf("msyscall %lx %lx error\\n"); + } } else { \_dl\_load\_list\_free(lowld); } Index: libexec/ld.so/aarch64/syscall.h =================================================================== RCS file: /cvs/src/libexec/ld.so/aarch64/syscall.h,v retrieving revision 1.7 diff -u -p -u -r1.7 syscall.h --- libexec/ld.so/aarch64/syscall.h 14 Jul 2019 03:23:12 -0000 1.7 +++ libexec/ld.so/aarch64/syscall.h 26 Nov 2019 16:11:22 -0000 @@ -48,6 +48,7 @@ int \_dl\_getthrid(void); int \_dl\_mprotect(const void \*, size\_t, int); int \_dl\_munmap(const void \*, size\_t); int \_dl\_open(const char \*, int); +int \_dl\_msyscall(void \*addr, size\_t len); ssize\_t \_dl\_read(int, const char \*, size\_t); int \_dl\_pledge(const char \*, const char \*\*); long \_dl\_\_\_syscall(quad\_t, ...); Index: libexec/ld.so/alpha/syscall.h =================================================================== RCS file: /cvs/src/libexec/ld.so/alpha/syscall.h,v retrieving revision 1.41 diff -u -p -u -r1.41 syscall.h --- libexec/ld.so/alpha/syscall.h 14 Jul 2019 03:23:12 -0000 1.41 +++ libexec/ld.so/alpha/syscall.h 26 Nov 2019 16:11:25 -0000 @@ -48,6 +48,7 @@ int \_dl\_getthrid(void); int \_dl\_mprotect(const void \*, size\_t, int); int \_dl\_munmap(const void \*, size\_t); int \_dl\_open(const char \*, int); +int \_dl\_msyscall(void \*addr, size\_t len); ssize\_t \_dl\_read(int, const char \*, size\_t); int \_dl\_pledge(const char \*, const char \*\*); long \_dl\_\_\_syscall(quad\_t, ...); Index: libexec/ld.so/amd64/syscall.h =================================================================== RCS file: /cvs/src/libexec/ld.so/amd64/syscall.h,v retrieving revision 1.28 diff -u -p -u -r1.28 syscall.h --- libexec/ld.so/amd64/syscall.h 14 Jul 2019 03:23:12 -0000 1.28 +++ libexec/ld.so/amd64/syscall.h 26 Nov 2019 16:11:28 -0000 @@ -48,6 +48,7 @@ int \_dl\_getthrid(void); int \_dl\_mprotect(const void \*, size\_t, int); int \_dl\_munmap(const void \*, size\_t); int \_dl\_open(const char \*, int); +int \_dl\_msyscall(void \*addr, size\_t len); ssize\_t \_dl\_read(int, const char \*, size\_t); int \_dl\_pledge(const char \*, const char \*\*); long \_dl\_\_\_syscall(quad\_t, ...); Index: libexec/ld.so/arm/syscall.h =================================================================== RCS file: /cvs/src/libexec/ld.so/arm/syscall.h,v retrieving revision 1.28 diff -u -p -u -r1.28 syscall.h --- libexec/ld.so/arm/syscall.h 14 Jul 2019 03:23:12 -0000 1.28 +++ libexec/ld.so/arm/syscall.h 26 Nov 2019 16:11:30 -0000 @@ -48,6 +48,7 @@ int \_dl\_getthrid(void); int \_dl\_mprotect(const void \*, size\_t, int); int \_dl\_munmap(const void \*, size\_t); int \_dl\_open(const char \*, int); +int \_dl\_msyscall(void \*addr, size\_t len); ssize\_t \_dl\_read(int, const char \*, size\_t); int \_dl\_pledge(const char \*, const char \*\*); long \_dl\_\_\_syscall(quad\_t, ...); Index: libexec/ld.so/hppa/syscall.h =================================================================== RCS file: /cvs/src/libexec/ld.so/hppa/syscall.h,v retrieving revision 1.28 diff -u -p -u -r1.28 syscall.h --- libexec/ld.so/hppa/syscall.h 14 Jul 2019 03:23:12 -0000 1.28 +++ libexec/ld.so/hppa/syscall.h 26 Nov 2019 16:11:33 -0000 @@ -48,6 +48,7 @@ int \_dl\_getthrid(void); int \_dl\_mprotect(const void \*, size\_t, int); int \_dl\_munmap(const void \*, size\_t); int \_dl\_open(const char \*, int); +int \_dl\_msyscall(void \*addr, size\_t len); ssize\_t \_dl\_read(int, const char \*, size\_t); int \_dl\_pledge(const char \*, const char \*\*); long \_dl\_\_\_syscall(quad\_t, ...); Index: libexec/ld.so/i386/syscall.h =================================================================== RCS file: /cvs/src/libexec/ld.so/i386/syscall.h,v retrieving revision 1.32 diff -u -p -u -r1.32 syscall.h --- libexec/ld.so/i386/syscall.h 14 Jul 2019 03:23:12 -0000 1.32 +++ libexec/ld.so/i386/syscall.h 26 Nov 2019 16:11:35 -0000 @@ -48,6 +48,7 @@ int \_dl\_getthrid(void); int \_dl\_mprotect(const void \*, size\_t, int); int \_dl\_munmap(const void \*, size\_t); int \_dl\_open(const char \*, int); +int \_dl\_msyscall(void \*addr, size\_t len); ssize\_t \_dl\_read(int, const char \*, size\_t); int \_dl\_pledge(const char \*, const char \*\*); long \_dl\_\_\_syscall(quad\_t, ...); Index: libexec/ld.so/m88k/syscall.h =================================================================== RCS file: /cvs/src/libexec/ld.so/m88k/syscall.h,v retrieving revision 1.24 diff -u -p -u -r1.24 syscall.h --- libexec/ld.so/m88k/syscall.h 14 Jul 2019 03:23:12 -0000 1.24 +++ libexec/ld.so/m88k/syscall.h 26 Nov 2019 16:11:37 -0000 @@ -48,6 +48,7 @@ int \_dl\_getthrid(void); int \_dl\_mprotect(const void \*, size\_t, int); int \_dl\_munmap(const void \*, size\_t); int \_dl\_open(const char \*, int); +int \_dl\_msyscall(void \*addr, size\_t len); ssize\_t \_dl\_read(int, const char \*, size\_t); int \_dl\_pledge(const char \*, const char \*\*); long \_dl\_\_\_syscall(quad\_t, ...); Index: libexec/ld.so/mips64/syscall.h =================================================================== RCS file: /cvs/src/libexec/ld.so/mips64/syscall.h,v retrieving revision 1.30 diff -u -p -u -r1.30 syscall.h --- libexec/ld.so/mips64/syscall.h 14 Jul 2019 03:23:12 -0000 1.30 +++ libexec/ld.so/mips64/syscall.h 26 Nov 2019 16:11:41 -0000 @@ -48,6 +48,7 @@ int \_dl\_getthrid(void); int \_dl\_mprotect(const void \*, size\_t, int); int \_dl\_munmap(const void \*, size\_t); int \_dl\_open(const char \*, int); +int \_dl\_msyscall(void \*addr, size\_t len); ssize\_t \_dl\_read(int, const char \*, size\_t); int \_dl\_pledge(const char \*, const char \*\*); long \_dl\_\_\_syscall(quad\_t, ...); Index: libexec/ld.so/powerpc/syscall.h =================================================================== RCS file: /cvs/src/libexec/ld.so/powerpc/syscall.h,v retrieving revision 1.47 diff -u -p -u -r1.47 syscall.h --- libexec/ld.so/powerpc/syscall.h 14 Jul 2019 03:23:12 -0000 1.47 +++ libexec/ld.so/powerpc/syscall.h 26 Nov 2019 16:11:43 -0000 @@ -48,6 +48,7 @@ int \_dl\_getthrid(void); int \_dl\_mprotect(const void \*, size\_t, int); int \_dl\_munmap(const void \*, size\_t); int \_dl\_open(const char \*, int); +int \_dl\_msyscall(void \*addr, size\_t len); ssize\_t \_dl\_read(int, const char \*, size\_t); int \_dl\_pledge(const char \*, const char \*\*); long \_dl\_\_\_syscall(quad\_t, ...); Index: libexec/ld.so/sh/syscall.h =================================================================== RCS file: /cvs/src/libexec/ld.so/sh/syscall.h,v retrieving revision 1.27 diff -u -p -u -r1.27 syscall.h --- libexec/ld.so/sh/syscall.h 14 Jul 2019 03:23:12 -0000 1.27 +++ libexec/ld.so/sh/syscall.h 26 Nov 2019 16:11:18 -0000 @@ -48,6 +48,7 @@ int \_dl\_getthrid(void); int \_dl\_mprotect(const void \*, size\_t, int); int \_dl\_munmap(const void \*, size\_t); int \_dl\_open(const char \*, int); +int \_dl\_msyscall(void \*addr, size\_t len); ssize\_t \_dl\_read(int, const char \*, size\_t); int \_dl\_pledge(const char \*, const char \*\*); long \_dl\_\_\_syscall(quad\_t, ...); Index: libexec/ld.so/sparc64/syscall.h =================================================================== RCS file: /cvs/src/libexec/ld.so/sparc64/syscall.h,v retrieving revision 1.40 diff -u -p -u -r1.40 syscall.h --- libexec/ld.so/sparc64/syscall.h 14 Jul 2019 03:23:12 -0000 1.40 +++ libexec/ld.so/sparc64/syscall.h 26 Nov 2019 16:11:15 -0000 @@ -48,6 +48,7 @@ int \_dl\_getthrid(void); int \_dl\_mprotect(const void \*, size\_t, int); int \_dl\_munmap(const void \*, size\_t); int \_dl\_open(const char \*, int); +int \_dl\_msyscall(void \*addr, size\_t len); ssize\_t \_dl\_read(int, const char \*, size\_t); int \_dl\_pledge(const char \*, const char \*\*); long \_dl\_\_\_syscall(quad\_t, ...); Index: usr.sbin/procmap/procmap.c =================================================================== RCS file: /cvs/src/usr.sbin/procmap/procmap.c,v retrieving revision 1.65 diff -u -p -u -r1.65 procmap.c --- usr.sbin/procmap/procmap.c 5 Feb 2019 02:17:32 -0000 1.65 +++ usr.sbin/procmap/procmap.c 27 Nov 2019 20:59:05 -0000 @@ -483,11 +483,11 @@ process\_map(kvm\_t \*kd, pid\_t pid, struct /\* headers \*/ #ifdef DISABLED\_HEADERS if (print\_map) - printf("%-\*s %-\*s rwx RWX CPY NCP I W A\\n", + printf("%-\*s %-\*s rwxSe RWX CPY NCP I W A\\n", (int)sizeof(long) \* 2 + 2, "Start", (int)sizeof(long) \* 2 + 2, "End"); if (print\_maps) - printf("%-\*s %-\*s rwxp %-\*s Dev Inode File\\n", + printf("%-\*s %-\*s rwxSep %-\*s Dev Inode File\\n", (int)sizeof(long) \* 2 + 0, "Start", (int)sizeof(long) \* 2 + 0, "End", (int)sizeof(long) \* 2 + 0, "Offset"); @@ -497,7 +497,7 @@ process\_map(kvm\_t \*kd, pid\_t pid, struct (int)sizeof(int) \* 2 - 1, "Size "); #endif if (print\_all) - printf("%-\*s %-\*s %\*s %-\*s rwxpc RWX I/W/A Dev %\*s - File\\n", + printf("%-\*s %-\*s %\*s %-\*s rwxpcSe RWX I/W/A Dev %\*s - File\\n", (int)sizeof(long) \* 2, "Start", (int)sizeof(long) \* 2, "End", (int)sizeof(int) \* 2, "Size ", @@ -719,11 +719,14 @@ dump\_vm\_map\_entry(kvm\_t \*kd, struct kbit name = findname(kd, vmspace, vme, vp, vfs, uvm\_obj); if (print\_map) { - printf("0x%lx 0x%lx %c%c%c %c%c%c %s %s %d %d %d", - vme->start, vme->end, + printf("0x%-\*lx 0x%-\*lx %c%c%c%c%c %c%c%c %s %s %d %d %d", + (int)sizeof(long) \* 2 + 0, vme->start, + (int)sizeof(long) \* 2 + 0, vme->end, (vme->protection & PROT\_READ) ? 'r' : '-', (vme->protection & PROT\_WRITE) ? 'w' : '-', (vme->protection & PROT\_EXEC) ? 'x' : '-', + (vme->etype & UVM\_ET\_STACK) ? 'S' : '-', + (vme->etype & UVM\_ET\_SYSCALL) ? 'e' : '-', (vme->max\_protection & PROT\_READ) ? 'r' : '-', (vme->max\_protection & PROT\_WRITE) ? 'w' : '-', (vme->max\_protection & PROT\_EXEC) ? 'x' : '-', @@ -743,12 +746,14 @@ dump\_vm\_map\_entry(kvm\_t \*kd, struct kbit } if (print\_maps) - printf("%0\*lx-%0\*lx %c%c%c%c %0\*lx %02x:%02x %llu %s\\n", + printf("0x%-\*lx 0x%-\*lx %c%c%c%c%c%c %0\*lx %02x:%02x %llu %s\\n", (int)sizeof(void \*) \* 2, vme->start, (int)sizeof(void \*) \* 2, vme->end, (vme->protection & PROT\_READ) ? 'r' : '-', (vme->protection & PROT\_WRITE) ? 'w' : '-', (vme->protection & PROT\_EXEC) ? 'x' : '-', + (vme->etype & UVM\_ET\_STACK) ? 'S' : '-', + (vme->etype & UVM\_ET\_SYSCALL) ? 'e' : '-', (vme->etype & UVM\_ET\_COPYONWRITE) ? 'p' : 's', (int)sizeof(void \*) \* 2, (unsigned long)vme->offset, @@ -761,11 +766,14 @@ dump\_vm\_map\_entry(kvm\_t \*kd, struct kbit vme->start, vme->end, vme->object.uvm\_obj, (unsigned long)vme->offset, vme->aref.ar\_amap, vme->aref.ar\_pageoff); - printf("\\tsubmap=%c, cow=%c, nc=%c, prot(max)=%d/%d, inh=%d, " + printf("\\tsubmap=%c, cow=%c, nc=%c, stack=%c, " + "syscall=%c, prot(max)=%d/%d, inh=%d, " "wc=%d, adv=%d\\n", (vme->etype & UVM\_ET\_SUBMAP) ? 'T' : 'F', (vme->etype & UVM\_ET\_COPYONWRITE) ? 'T' : 'F', (vme->etype & UVM\_ET\_NEEDSCOPY) ? 'T' : 'F', + (vme->etype & UVM\_ET\_STACK) ? 'T' : 'F', + (vme->etype & UVM\_ET\_SYSCALL) ? 'T' : 'F', vme->protection, vme->max\_protection, vme->inheritance, vme->wired\_count, vme->advice); if (inode && verbose) @@ -805,13 +813,15 @@ dump\_vm\_map\_entry(kvm\_t \*kd, struct kbit } sz = (size\_t)((vme->end - vme->start) / 1024); - printf("%0\*lx-%0\*lx %7luk %0\*lx %c%c%c%c%c (%c%c%c) %d/%d/%d %02u:%02u %7llu - %s", + printf("%0\*lx-%0\*lx %7luk %0\*lx %c%c%c%c%c%c%c (%c%c%c) %d/%d/%d %02u:%02u %7llu - %s", (int)sizeof(void \*) \* 2, vme->start, (int)sizeof(void \*) \* 2, vme->end - (vme->start != vme->end ? 1 : 0), (unsigned long)sz, (int)sizeof(void \*) \* 2, (unsigned long)vme->offset, (vme->protection & PROT\_READ) ? 'r' : '-', (vme->protection & PROT\_WRITE) ? 'w' : '-', (vme->protection & PROT\_EXEC) ? 'x' : '-', + (vme->etype & UVM\_ET\_STACK) ? 'S' : '-', + (vme->etype & UVM\_ET\_SYSCALL) ? 'e' : '-', (vme->etype & UVM\_ET\_COPYONWRITE) ? 'p' : 's', (vme->etype & UVM\_ET\_NEEDSCOPY) ? '+' : '-', (vme->max\_protection & PROT\_READ) ? 'r' : '-', **\[[prev in list](https://marc.info/?l=openbsd-tech&m=157488269713173&w=2)\] \[[next in list](https://marc.info/?l=openbsd-tech&m=157489224118677&w=2)\] \[prev in thread\] \[[next in thread](https://marc.info/?l=openbsd-tech&m=157489224118677&w=2)\] ** 
```  

[Configure](https://marc.info/?q=configure) | [About](https://marc.info/?q=about) | [News](https://marc.info/?q=news) | [Add a list](mailto:webguy@marc.info?subject=Add%20a%20list%20to%20MARC) | Sponsored by [KoreLogic](http://www.korelogic.com/)

  
  
from Hacker News https://ift.tt/2qV7jR9